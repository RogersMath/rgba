<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>[RGBA] Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="gameContainer">
        <canvas id="glslCanvas"></canvas>
        
        <div id="gameUI">
            <!-- Top Bar -->
            <div id="topBar">
                <div id="scoreTime">Score: <span id="score">0</span> | Time: <span id="time">0:00</span></div>
                <div id="rank">APPRENTICE</div>
                <button id="menuBtn">☰</button>
            </div>
            
            <!-- Objective Display -->
            <div id="objective">
                <div id="objectiveFunction">f(R,G,B) = <span id="rCoeff">0.33</span>×R + <span id="gCoeff">0.33</span>×G + <span id="bCoeff">0.33</span>×B</div>
                <div id="constraints">
                    <span>R: <span id="rMin">3.5</span>-<span id="rMax">20.5</span></span>
                    <span>G: <span id="gMin">3.5</span>-<span id="gMax">20.5</span></span>
                    <span>B: <span id="bMin">3.5</span>-<span id="bMax">20.5</span></span>
                    <span>A: <span id="aVal">0</span></span>
                </div>
            </div>
            
            <!-- Cards Area -->
            <div id="cardsArea">
                <div class="card" data-card="0">
                    <div class="card-equation" id="equation0">?</div>
                    <div class="card-effects" id="effects0">?</div>
                </div>
                <div class="card" data-card="1">
                    <div class="card-equation" id="equation1">?</div>
                    <div class="card-effects" id="effects1">?</div>
                </div>
                <div class="card" data-card="2">
                    <div class="card-equation" id="equation2">?</div>
                    <div class="card-effects" id="effects2">?</div>
                </div>
            </div>
            
            <!-- Current Status -->
            <div id="currentRGB">
                Current: R=<span id="currentR">12</span> G=<span id="currentG">15</span> B=<span id="currentB">8</span> | Value: <span id="currentValue">11.65</span>
            </div>
            
            <!-- Numpad -->
            <div id="numpad">
                <button class="numpad-btn" data-num="7">7</button>
                <button class="numpad-btn" data-num="8">8</button>
                <button class="numpad-btn" data-num="9">9</button>
                <button class="numpad-btn" data-num="4">4</button>
                <button class="numpad-btn" data-num="5">5</button>
                <button class="numpad-btn" data-num="6">6</button>
                <button class="numpad-btn" data-num="1">1</button>
                <button class="numpad-btn" data-num="2">2</button>
                <button class="numpad-btn" data-num="3">3</button>
            </div>
        </div>
        
        <!-- Settings Overlay -->
        <div id="settingsOverlay">
            <div id="settingsContent">
                <h2>Game Paused</h2>
                <p>Problems Solved: <span id="statProblems">0</span></p>
                <p>Time This Run: <span id="statTime">0:00</span></p>
                <p>Best Score: <span id="statBest">0</span></p>
                <p>Current Rank: <span id="statRank">APPRENTICE</span></p>
                <label id="accessibilityToggle">
                    <input type="checkbox" id="accessibilityCheckbox">
                    Visually Impaired Mode
                </label>
            </div>
            <button id="closeSettings">Resume Game</button>
        </div>
    </div>

    <!-- The WebGL/Shader script remains here as requested -->
    <script>
        const canvas = document.getElementById('glslCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported!');
        }

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            #define RESOLUTION iResolution
            #define TIME iTime
            #define MAX_MARCHES 30
            #define TOLERANCE   0.0001
            #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
            const mat2 rot0 = ROT(0.0);
            mat2 g_rot0 = rot0;
            mat2 g_rot1 = rot0;
            float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
            vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }
            const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 hsv2rgb(vec3 c) {
              vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
              return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
            }
            float apolloian(vec3 p, float s, out float h) {
              float scale = 1.0;
              for(int i=0; i < 5; ++i) {
                p = -1.0 + 2.0*fract(0.5*p+0.5);
                float r2 = dot(p,p);
                float k  = s/r2;
                p       *= k;
                scale   *= k;
              }
              vec3 ap = abs(p/scale);
              float d = min(length(ap.xy),ap.z);
              h = (d == ap.z) ? 0.5 : 0.0;
              return d;
            }
            float df(vec2 p, out float h) {
              float z = 1.55;
              p /= z;
              vec3 p3 = vec3(p,0.1);
              p3.xz*=g_rot0;
              p3.yz*=g_rot1;
              float d = apolloian(p3, 1.0/z, h);
              return d * z;
            }
            float shadow(vec2 lp, vec2 ld, float mint, float maxt) {
              float t = mint;
              float nd = 1E6;
              float h;
              for (int i=0; i < MAX_MARCHES; ++i) {
                vec2 p = lp + ld*t;
                float d = df(p, h);
                if (d < TOLERANCE || t >= maxt) {
                  float sd = 1.0-exp(-1.5*max(t/maxt-0.05, 0.0));
                  return t >= maxt ? mix(sd, 1.0, smoothstep(0.0, 0.025, nd)) : sd;
                }
                nd = min(nd, d);
                t += 0.6*d;
              }
              return 1.0-exp(-1.5*max(t/maxt-0.05, 0.0));
            }
            vec3 effect(vec2 p) {
              float a = 0.1*TIME;
              g_rot0 = ROT(0.5*a);
              g_rot1 = ROT(sqrt(0.5)*a);
              vec2  lightPos  = vec2(0.0, 1.0) * g_rot1;
              vec2  lightDiff = lightPos - p;
              float lightLen  = length(lightDiff);
              vec2  lightDir  = lightDiff / lightLen;
              vec3  lightPos3 = vec3(lightPos, 0.0);
              vec3  p3        = vec3(p, -1.0);
              float lightLen3 = distance(lightPos3, p3);
              vec3  lightDir3 = normalize(lightPos3-p3);
              float diff      = max(dot(lightDir3, vec3(0.0, 0.0, 1.0)), 0.0);
              float h;
              float d   = df(p, h);
              float ss  = shadow(p,lightDir, 0.005, lightLen);
              vec3 bcol = hsv2rgb(vec3(fract(h-0.2*length(p)+0.25*TIME), 0.666, 1.0));
              vec3 col = vec3(0.0);
              col += mix(0., 1.0, diff)*0.5*mix(0.1, 1.0, ss)/(lightLen3*lightLen3);
              col += exp(-300.0*abs(d))*sqrt(bcol);
              col += exp(-40.0*max(lightLen-0.02, 0.0));
              return col;
            }
            void main() {
              vec2 q = gl_FragCoord.xy/RESOLUTION.xy;
              vec2 p = -1. + 2. * q;
              p.x *= RESOLUTION.x/RESOLUTION.y;
              vec3 col = effect(p);
              col *= smoothstep(0.0, 4.0, TIME);
              col = sRGB(col);
              gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error(`Error compiling shader:`, gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
            console.error('Error linking program:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const resolutionUniformLocation = gl.getUniformLocation(program, "iResolution");
        const timeUniformLocation = gl.getUniformLocation(program, "iTime");

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        gl.useProgram(program);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    </script>
    
    <!-- The main game logic is now in its own file -->
    <script src="script.js" defer></script>
</body>
</html>
