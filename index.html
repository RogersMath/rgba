<!DOCTYPE html>
<html>
<head>
<title>[RGBA] Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
    
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
        font-family: 'Courier New', monospace;
        background: #000;
        outline: none;
    }
    
    #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        max-width: calc(100vh * 9/16);
        max-height: calc(100vw * 16/9);
        margin: 0 auto;
        background: #000;
        overflow: hidden;
    }
    
    #glslCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }
    
    #gameUI {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        display: flex;
        flex-direction: column;
        color: white;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    /* Top Bar */
    #topBar {
        height: 5%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 20px;
        background: rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
    }
    
    #scoreTime {
        font-size: 14px;
        font-weight: bold;
    }
    
    #rank {
        font-size: 18px;
        font-weight: bold;
        text-align: center;
    }
    
    #menuBtn {
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        padding: 5px;
    }
    
    /* Objective Function Display */
    #objective {
        height: 15%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(0,0,0,0.2);
        backdrop-filter: blur(5px);
        padding: 10px;
    }
    
    #objectiveFunction {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 10px;
    }
    
    #constraints {
        font-size: 14px;
        display: flex;
        gap: 20px;
    }
    
    /* Cards Area */
    #cardsArea {
        height: 35%;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        padding: 20px;
    }
    
    .card {
        flex: 1;
        max-width: 120px;
        height: 80%;
        background: rgba(255,255,255,0.1);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 15px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .card:hover {
        background: rgba(255,255,255,0.2);
        transform: translateY(-2px);
    }
    
    .card-equation {
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 10px;
    }
    
    .card-effects {
        font-size: 11px;
        line-height: 1.3;
    }
    
    /* Current RGB Display */
    #currentRGB {
        height: 10%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0,0,0,0.2);
        backdrop-filter: blur(5px);
        font-size: 16px;
        font-weight: bold;
    }
    
    /* Numpad */
    #numpad {
        height: 35%;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        gap: 8px;
        padding: 20px;
    }
    
    .numpad-btn {
        background: rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
        color: white;
        border: 3px solid;
        border-radius: 0;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.1s;
        font-family: 'Courier New', monospace;
    }
    
    .numpad-btn:hover {
        background: rgba(255,255,255,0.1);
        transform: scale(0.95);
    }
    
    .numpad-btn:active {
        transform: scale(0.9);
    }
    
    /* Settings Overlay */
    #settingsOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        backdrop-filter: blur(20px);
        z-index: 100;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        padding: 40px;
    }
    
    #settingsContent {
        text-align: center;
        font-size: 16px;
        line-height: 2;
    }
    
    #closeSettings {
        margin-top: 30px;
        padding: 10px 30px;
        background: rgba(255,255,255,0.2);
        border: 2px solid white;
        color: white;
        font-size: 16px;
        cursor: pointer;
    }
    
    @media (max-width: 480px) {
        #cardsArea {
            flex-direction: column;
            gap: 5px;
            padding: 10px;
        }
        
        .card {
            max-width: none;
            width: 90%;
            height: 30%;
        }
        
        #numpad {
            padding: 10px;
            gap: 5px;
        }
        
        .numpad-btn {
            font-size: 20px;
        }
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="glslCanvas"></canvas>
    
    <div id="gameUI">
        <div id="topBar">
            <div id="scoreTime">Score: <span id="score">0</span> | Time: <span id="time">0:00</span></div>
            <div id="rank">APPRENTICE</div>
            <button id="menuBtn">☰</button>
        </div>
        
        <div id="objective">
            <div id="objectiveFunction">f(R,G,B) = <span id="rCoeff">0.33</span>×R + <span id="gCoeff">0.33</span>×G + <span id="bCoeff">0.33</span>×B</div>
            <div id="constraints">
                <span>R: <span id="rMin">3.5</span>-<span id="rMax">20.5</span></span>
                <span>G: <span id="gMin">3.5</span>-<span id="gMax">20.5</span></span>
                <span>B: <span id="bMin">3.5</span>-<span id="bMax">20.5</span></span>
            </div>
        </div>
        
        <div id="cardsArea">
            <div class="card" data-card="0">
                <div class="card-equation" id="equation0">2+3</div>
                <div class="card-effects" id="effects0">+5% R Coeff<br>-2% G Coeff</div>
            </div>
            <div class="card" data-card="1">
                <div class="card-equation" id="equation1">7-4</div>
                <div class="card-effects" id="effects1">+3% B Coeff<br>+1 B Min</div>
            </div>
            <div class="card" data-card="2">
                <div class="card-equation" id="equation2">9-6</div>
                <div class="card-effects" id="effects2">-4% R Coeff<br>+6% G Coeff</div>
            </div>
        </div>
        
        <div id="currentRGB">
            Current: R=<span id="currentR">12</span> G=<span id="currentG">15</span> B=<span id="currentB">8</span> | Value: <span id="currentValue">11.65</span>
        </div>
        
        <div id="numpad">
            <button class="numpad-btn" data-num="7">7</button>
            <button class="numpad-btn" data-num="8">8</button>
            <button class="numpad-btn" data-num="9">9</button>
            <button class="numpad-btn" data-num="4">4</button>
            <button class="numpad-btn" data-num="5">5</button>
            <button class="numpad-btn" data-num="6">6</button>
            <button class="numpad-btn" data-num="1">1</button>
            <button class="numpad-btn" data-num="2">2</button>
            <button class="numpad-btn" data-num="3">3</button>
        </div>
    </div>
    
    <div id="settingsOverlay">
        <div id="settingsContent">
            <h2>Game Paused</h2>
            <p>Problems Solved: <span id="statProblems">0</span></p>
            <p>Time This Run: <span id="statTime">0:00</span></p>
            <p>Best Score: <span id="statBest">0</span></p>
            <p>Current Rank: <span id="statRank">APPRENTICE</span></p>
        </div>
        <button id="closeSettings">Resume Game</button>
    </div>
</div>

<script>
    // --- WebGL Shader Setup ---
    const canvas = document.getElementById('glslCanvas');
    const gl = canvas.getContext('webgl');
    
    if (!gl) {
        alert('WebGL not supported!');
    }
    
    const vertexShaderSource = `
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    const fragmentShaderSource = `
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;

        #define RESOLUTION iResolution
        #define TIME iTime
        #define MAX_MARCHES 30
        #define TOLERANCE   0.0001
        #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
        #define PI          3.141592654
        #define TAU         (2.0*PI)

        const mat2 rot0 = ROT(0.0);
        mat2 g_rot0 = rot0;
        mat2 g_rot1 = rot0;

        float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
        vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

        const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 hsv2rgb(vec3 c) {
          vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
          return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
        }

        float apolloian(vec3 p, float s, out float h) {
          float scale = 1.0;
          for(int i=0; i < 5; ++i) {
            p = -1.0 + 2.0*fract(0.5*p+0.5);
            float r2 = dot(p,p);
            float k  = s/r2;
            p       *= k;
            scale   *= k;
          }

          vec3 ap = abs(p/scale);
          float d = length(ap.xy);
          d = min(d, ap.z);

          float hh = 0.0;
          if (d == ap.z){
            hh += 0.5;
          }
          h = hh;
          return d;
        }

        float df(vec2 p, out float h) {
          const float fz = 1.0-0.0;
          float z = 1.55*fz;
          p /= z;
          vec3 p3 = vec3(p,0.1);
          p3.xz*=g_rot0;
          p3.yz*=g_rot1;
          float d = apolloian(p3, 1.0/fz, h);
          d *= z;
          return d;
        }

        float shadow(vec2 lp, vec2 ld, float mint, float maxt) {
          const float ds = 1.0-0.4;
          float t = mint;
          float nd = 1E6;
          float h;
          const float soff = 0.05;
          const float smul = 1.5;
          for (int i=0; i < MAX_MARCHES; ++i) {
            vec2 p = lp + ld*t;
            float d = df(p, h);
            if (d < TOLERANCE || t >= maxt) {
              float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));
              return t >= maxt ? mix(sd, 1.0, smoothstep(0.0, 0.025, nd)) : sd;
            }
            nd = min(nd, d);
            t += ds*d;
          }
          float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));
          return sd;
        }

        vec3 effect(vec2 p, vec2 q) {
          float aa = 2.0/RESOLUTION.y;
          float a = 0.1*TIME;
          g_rot0 = ROT(0.5*a);
          g_rot1 = ROT(sqrt(0.5)*a);

          vec2  lightPos  = vec2(0.0, 1.0);
          lightPos        *= (g_rot1);
          vec2  lightDiff = lightPos - p;
          float lightD2   = dot(lightDiff,lightDiff);
          float lightLen  = sqrt(lightD2);
          vec2  lightDir  = lightDiff / lightLen;
          vec3  lightPos3 = vec3(lightPos, 0.0);
          vec3  p3        = vec3(p, -1.0);
          float lightLen3 = distance(lightPos3, p3);
          vec3  lightDir3 = normalize(lightPos3-p3);
          vec3  n3        = vec3(0.0, 0.0, 1.0);
          float diff      = max(dot(lightDir3, n3), 0.0);

          float h;
          float d   = df(p, h);
          float ss  = shadow(p,lightDir, 0.005, lightLen);
          vec3 bcol = hsv2rgb(vec3(fract(h-0.2*length(p)+0.25*TIME), 0.666, 1.0));

          vec3 col = vec3(0.0);
          col += mix(0., 1.0, diff)*0.5*mix(0.1, 1.0, ss)/(lightLen3*lightLen3);
          col += exp(-300.0*abs(d))*sqrt(bcol);
          col += exp(-40.0*max(lightLen-0.02, 0.0));

          return col;
        }

        void main() {
          vec2 q = gl_FragCoord.xy/RESOLUTION.xy;
          vec2 p = -1. + 2. * q;
          p.x *= RESOLUTION.x/RESOLUTION.y;

          vec3 col = effect(p, q);
          col *= mix(0.0, 1.0, smoothstep(0.0, 4.0, TIME));
          col = sRGB(col);

          gl_FragColor = vec4(col, 1.0);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            return shader;
        }
        console.error(`Error compiling shader type ${type}:`, gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
            return program;
        }
        console.error('Error linking program:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    // Get locations of attributes and uniforms
    const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    const resolutionUniformLocation = gl.getUniformLocation(program, "iResolution");
    const timeUniformLocation = gl.getUniformLocation(program, "iTime");

    // Create a buffer to hold the vertices
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]; // Two triangles to cover the canvas
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    // --- FIX [1]: This section tells WebGL how to read the vertex data. It was missing. ---
    // This needs to be done once during setup.
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(
        positionAttributeLocation,
        2,        // 2 components per vertex (x, y)
        gl.FLOAT, // Data is 32bit floats
        false,    // Don't normalize
        0,        // Stride - 0 means auto
        0         // Offset - start at the beginning
    );
    // --- End of FIX [1] ---

    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const rect = container.getBoundingClientRect();
        
        // Check if size is valid to prevent WebGL errors
        if (rect.width > 0 && rect.height > 0) {
            canvas.width = rect.width;
            canvas.height = rect.height;
            // The viewport also needs to be set here for immediate response
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
    }
    window.addEventListener('resize', resizeCanvas);
    
    // --- Game State ---
    let gameState = {
        score: 0,
        startTime: Date.now(),
        coefficients: { r: 0.33, g: 0.33, b: 0.33 },
        constraints: { rMin: 3.5, rMax: 20.5, gMin: 3.5, gMax: 20.5, bMin: 3.5, bMax: 20.5 },
        currentRGB: { r: 12, g: 15, b: 8 },
        cards: [],
        problemsSolved: 0,
        bestScore: parseInt(localStorage.getItem('rgbaBestScore') || '0'),
        isPaused: false
    };

    // --- Game Logic Functions (unchanged) ---
    function generateRGB() {
        const r = Math.random() * (gameState.constraints.rMax - gameState.constraints.rMin) + gameState.constraints.rMin;
        const g = Math.random() * (gameState.constraints.gMax - gameState.constraints.gMin) + gameState.constraints.gMin;
        const b = Math.random() * (gameState.constraints.bMax - gameState.constraints.bMin) + gameState.constraints.bMin;
        return { r: Math.round(r * 10) / 10, g: Math.round(g * 10) / 10, b: Math.round(b * 10) / 10 };
    }

    function calculateValue(rgb = gameState.currentRGB) {
        return gameState.coefficients.r * rgb.r + gameState.coefficients.g * rgb.g + gameState.coefficients.b * rgb.b;
    }

    function generateEquation() {
        const operations = ['+', '-'];
        const op = operations[Math.floor(Math.random() * operations.length)];
        let a, b, result;
        
        if (op === '+') {
            a = Math.floor(Math.random() * 5) + 1;
            b = Math.floor(Math.random() * 5) + 1;
            result = a + b;
        } else {
            result = Math.floor(Math.random() * 8) + 2;
            b = Math.floor(Math.random() * (result - 1)) + 1;
            a = result + b;
        }
        
        return { equation: `${a}${op}${b}`, answer: result };
    }

    function generateCardEffect() {
        const effects = [];
        const variables = ['r', 'g', 'b'];
        const numEffects = Math.floor(Math.random() * 2) + 1;
        
        for (let i = 0; i < numEffects; i++) {
            const variable = variables[Math.floor(Math.random() * variables.length)];
            const effectType = Math.floor(Math.random() * 3);
            
            if (effectType === 0) {
                const change = (Math.random() - 0.5) * 0.2;
                effects.push({ type: 'coeff', variable: variable, change: change, display: `${change > 0 ? '+' : ''}${Math.round(change * 100)}% ${variable.toUpperCase()} Coeff` });
            } else if (effectType === 1) {
                const change = (Math.random() - 0.5) * 4;
                effects.push({ type: 'min', variable: variable, change: change, display: `${change > 0 ? '+' : ''}${Math.round(change * 10) / 10} ${variable.toUpperCase()} Min` });
            } else {
                const change = (Math.random() - 0.5) * 4;
                effects.push({ type: 'max', variable: variable, change: change, display: `${change > 0 ? '+' : ''}${Math.round(change * 10) / 10} ${variable.toUpperCase()} Max` });
            }
        }
        
        return effects;
    }

    function getCardGradient(effects) {
        const colors = { r: 0, g: 0, b: 0 };
        effects.forEach(effect => {
            if (effect.type === 'coeff') colors[effect.variable] += Math.abs(effect.change);
        });
        const total = colors.r + colors.g + colors.b;
        if (total === 0) return 'rgba(255,255,255,0.3)';
        const r = Math.round((colors.r / total) * 255);
        const g = Math.round((colors.g / total) * 255);
        const b = Math.round((colors.b / total) * 255);
        return `rgba(${r},${g},${b},0.3)`;
    }

    function generateCards() {
        gameState.cards = [];
        for (let i = 0; i < 3; i++) {
            const eq = generateEquation();
            const effects = generateCardEffect();
            gameState.cards.push({ equation: eq.equation, answer: eq.answer, effects: effects });
        }
        updateCardsDisplay();
    }
    
    // --- UI Update and Event Handling ---
    function updateCardsDisplay() {
        gameState.cards.forEach((card, i) => {
            document.getElementById(`equation${i}`).textContent = card.equation;
            document.getElementById(`effects${i}`).innerHTML = card.effects.map(e => e.display).join('<br>');
            const cardElement = document.querySelector(`[data-card="${i}"]`);
            const gradient = getCardGradient(card.effects);
            cardElement.style.borderColor = gradient;
        });
    }

    function applyCardEffects(cardIndex) {
        const card = gameState.cards[cardIndex];
        card.effects.forEach(effect => {
            if (effect.type === 'coeff') {
                gameState.coefficients[effect.variable] = Math.max(0, Math.min(1, gameState.coefficients[effect.variable] + effect.change));
            } else if (effect.type === 'min') {
                gameState.constraints[effect.variable + 'Min'] = Math.max(0, gameState.constraints[effect.variable + 'Min'] + effect.change);
            } else if (effect.type === 'max') {
                gameState.constraints[effect.variable + 'Max'] = Math.min(255, gameState.constraints[effect.variable + 'Max'] + effect.change);
            }
        });
    }

    function updateDisplays() {
        document.getElementById('score').textContent = Math.round(gameState.score);
        const elapsed = Date.now() - gameState.startTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        let rank = 'APPRENTICE';
        if (gameState.score >= 10000) rank = 'GRANDMASTER';
        else if (gameState.score >= 5000) rank = 'EXPERT';
        else if (gameState.score >= 2000) rank = 'JOURNEYMAN';
        else if (gameState.score >= 500) rank = 'ADEPT';
        document.getElementById('rank').textContent = rank;
        document.getElementById('rCoeff').textContent = gameState.coefficients.r.toFixed(2);
        document.getElementById('gCoeff').textContent = gameState.coefficients.g.toFixed(2);
        document.getElementById('bCoeff').textContent = gameState.coefficients.b.toFixed(2);
        document.getElementById('rMin').textContent = gameState.constraints.rMin.toFixed(1);
        document.getElementById('rMax').textContent = gameState.constraints.rMax.toFixed(1);
        document.getElementById('gMin').textContent = gameState.constraints.gMin.toFixed(1);
        document.getElementById('gMax').textContent = gameState.constraints.gMax.toFixed(1);
        document.getElementById('bMin').textContent = gameState.constraints.bMin.toFixed(1);
        document.getElementById('bMax').textContent = gameState.constraints.bMax.toFixed(1);
        document.getElementById('currentR').textContent = gameState.currentRGB.r;
        document.getElementById('currentG').textContent = gameState.currentRGB.g;
        document.getElementById('currentB').textContent = gameState.currentRGB.b;
        document.getElementById('currentValue').textContent = calculateValue().toFixed(2);
        const rgb = gameState.currentRGB;
        const borderColor = `rgb(${Math.round(rgb.r * 12)}, ${Math.round(rgb.g * 12)}, ${Math.round(rgb.b * 12)})`;
        document.querySelectorAll('.numpad-btn').forEach(btn => btn.style.borderColor = borderColor);
    }

    function handleNumberInput(number) {
        if (gameState.isPaused) return;
        let correctCard = gameState.cards.findIndex(card => card.answer === number);
        const currentValue = calculateValue();
        
        if (correctCard !== -1) {
            gameState.score += currentValue;
            gameState.problemsSolved++;
            applyCardEffects(correctCard);
            generateCards();
        } else {
            gameState.score -= currentValue / 2;
            if (gameState.score < 0) gameState.score = 0;
        }
        
        gameState.currentRGB = generateRGB();
        if (gameState.score > gameState.bestScore) {
            gameState.bestScore = gameState.score;
            localStorage.setItem('rgbaBestScore', gameState.bestScore.toString());
        }
        updateDisplays();
        if (gameState.score >= 10000) alert('Victory! You reached 10,000 points!');
    }

    document.getElementById('menuBtn').addEventListener('click', () => {
        gameState.isPaused = true;
        document.getElementById('settingsOverlay').style.display = 'flex';
        document.getElementById('statProblems').textContent = gameState.problemsSolved;
        const elapsed = Date.now() - gameState.startTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        document.getElementById('statTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('statBest').textContent = Math.round(gameState.bestScore);
        document.getElementById('statRank').textContent = document.getElementById('rank').textContent;
    });

    document.getElementById('closeSettings').addEventListener('click', () => {
        gameState.isPaused = false;
        document.getElementById('settingsOverlay').style.display = 'none';
    });

    document.querySelectorAll('.numpad-btn').forEach(btn => {
        btn.addEventListener('click', () => handleNumberInput(parseInt(btn.dataset.num)));
    });

    document.querySelectorAll('.card').forEach((card, i) => {
        card.addEventListener('click', () => {
            if (gameState.isPaused) return;
            handleNumberInput(gameState.cards[i].answer);
        });
    });

    // --- FIX [2]: Attach keyboard listeners to `window` for robustness. ---
    // This ensures key presses are captured regardless of which element has focus.
    window.addEventListener('keydown', (e) => {
        if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (gameState.isPaused) {
            if (e.key === 'Escape') document.getElementById('closeSettings').click();
            return;
        }

        if (e.key >= '1' && e.key <= '9') {
            const number = parseInt(e.key);
            handleNumberInput(number);
            const btn = document.querySelector(`[data-num="${number}"]`);
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                btn.style.background = 'rgba(255,255,255,0.3)';
            }
        } else if (['Escape', 'm', 'M'].includes(e.key)) {
            document.getElementById('menuBtn').click();
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key >= '1' && e.key <= '9') {
            const btn = document.querySelector(`[data-num="${e.key}"]`);
            if (btn) {
                btn.style.transform = 'scale(1)';
                btn.style.background = 'rgba(0,0,0,0.3)';
            }
        }
    });
    // --- End of FIX [2] ---

    // --- Game Initialization and Render Loop ---
    function initGame() {
        resizeCanvas();
        gameState.currentRGB = generateRGB();
        generateCards();
        updateDisplays();
    }

    let shaderTime = 0;
    let lastTime = 0;
    function render(time) {
        if (!gameState.isPaused) {
            // Use delta time for smoother animation if tab is inactive
            const deltaTime = lastTime > 0 ? (time - lastTime) * 0.001 : 0;
            shaderTime += deltaTime;
        }
        lastTime = time;

        if (program && gl.canvas.width > 0 && gl.canvas.height > 0) {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program); // Tell WebGL to use our shader program
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeUniformLocation, shaderTime);
            gl.drawArrays(gl.TRIANGLES, 0, 6); // Draw the 2 triangles
        }
        requestAnimationFrame(render);
    }

    // Start the game
    initGame();
    requestAnimationFrame(render);
</script>
</body>
</html>
